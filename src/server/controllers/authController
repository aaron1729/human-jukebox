const spotifyApi = require('../utils/apiWrapper');
const db = require('../models/models');


const authController = {};

// save the cookies spotifyId, access, and refresh on res.locals, possibly for later use (e.g. in authController.spotifyIdAndAccessToDb).
// store a boolean as res.locals.cookieMatch based on whether the cookies "spotifyId" and "access" exist and are a match in our db
authController.checkCookies = (req, res, next) => {
    try {
        console.log('inside of authController.checkCookies')
        res.locals.spotifyId = req.cookies.spotifyId;
        res.locals.access = req.cookies.access;
        res.locals.refresh = req.cookies.refresh;
        
        const spotifyId = res.locals.spotifyId;
        const access = res.locals.access;

        if (!spotifyId || !access) {
            res.locals.cookieMatch = false;
            return next();
        }
        const getHandleAndAccessFromDbQueryString = `SELECT handle, access FROM public.musicians WHERE spotify_id = '${spotifyId}'`;
        db.query(getHandleAndAccessFromDbQueryString).then(data => {
            console.log('after db query inside of authController.checkCookies, the data is:', data.rows)
            const accessFromDb = data.rows[0].access;
            const handleFromDb = data.rows[0].handle;
            if (access === accessFromDb) {
                res.locals.cookieMatch = true;
                res.locals.handle = handleFromDb;
            } else {
                res.locals.cookieMatch = false;
            }
            return next();
        });
    } catch(err) {
        return next({
            log: 'error checking cookies',
            status: err.statusCode,
            message: {error: 'failed to check cookies'}
        });
    }
}


// when this is used, it follows the above middleware. if cookies don't match, it ends the request/response cycle.
authController.endCycleIfCookiesUnmatched = (req, res, next) => {
    console.log('inside of authController.endCycleIfCookiesUnmatched');
    if (!res.locals.cookieMatch) {
        return res.status(200).json({error: 'sorry, cookies did not match'})
    } else {
        return next();
    }
}


// get two tokens (long strings)
    // set them as cookies called 'access' and 'refresh'
    // also save them on res.locals
    // also invoke the spotifyApi methods setAccessToken and setRefreshToken with these arguments [added 12/13/2022... is this helpful / needed / doesn't break anything?]
// when this function is triggered, req.query.code has been set to equal a massive string (sent by the spotify redirect).
authController.getTokens = (req, res, next) => {
    console.log('inside of authController.getTokens middleware, and req.query.code is:', req.query.code);
    try {
        spotifyApi.authorizationCodeGrant(req.query.code)
        .then(data => {
            // can additionally set an expiration on the cookie (say N minutes) e.g. using res.cookie('cookieName', cookieValue, {maxAge: 1000 * 60 * N})
            res.cookie('access', data.body.access_token).cookie('refresh', data.body.refresh_token);
            res.locals.access = data.body.access_token;
            res.locals.refresh = data.body.refresh_token;
            spotifyApi.setAccessToken(res.locals.access);
            spotifyApi.setRefreshToken(res.locals.refresh);
            return next();
        })
    } catch(err) {
        return next({
            log: 'error getting access and refresh tokens',
            status: err.statusCode,
            message: {error: 'failed to get access and refresh tokens'}
        });
    }
}


// given a refresh token, get a new access token and save it:
    // on res.locals
    // on the response object, to be set as a new cookie on the browser
    // in the Spotify API wrapper
authController.getNewAccessToken = (req, res, next) => {
    console.log('inside of authController.getNewAccessToken middleware, and cookies are', req.cookies);
    const refresh = req.cookies.refresh;
    try {
        spotifyApi.setRefreshToken(refresh);
        spotifyApi.refreshAccessToken()
        .then(data => {
            console.log('the returned data from spotifyApi.refreshAccessToken is', data.body.access_token);
            const access = data.body.access_token
            res.locals.access = access;
            res.cookie('access', access);
            spotifyApi.setAccessToken(access);
            return next();
        })
    } catch(err) {
        return next({
            log: 'error refreshing access token',
            status: err.statusCode,
            message: {error: 'failed to refresh access token.'}
        })
    }
}


// using a musician's spotify access token (saved as res.locals.access), get their spotify id and set it as res.locals.spotifyId .
authController.getSpotifyId = (req, res, next) => {
    try {
        spotifyApi.setAccessToken(res.locals.access);
        spotifyApi.getMe().then(userData => {
                res.locals.spotifyId = userData.body.id;
                res.cookie('spotifyId', res.locals.spotifyId);
                return next();
            }
        )
    } catch(err) {
        return next({
            log: 'error getting spotify id',
            status: err.statusCode,
            message: {error: 'failed to get spotify id. (perhaps you\'re in dev mode and the user isn\'t whitelisted in your spotify developer dashboard?)'}
        });
    }
}


// upsert the spotify id and access token (saved as res.locals.spotifyId and res.locals.access) to the database. more specifically, check if the spotify id is in the database, and:
    // if so, update its access token there;
    // if not, create a new row in the database with some default values. in particular, the new handle is a 
authController.spotifyIdAndAccessToDb = (req, res, next) => {
    try {
        const spotifyId = res.locals.spotifyId;
        const access = res.locals.access;

        // this is meant to avoid the possibility that one user's spotify id is another user's handle. of course, there is still some _tiny_ possibility of a collision, which should eventually be handled as well.
        const randomString = Math.floor(Math.random() * 10000).toString();

        const upsertMusicianInfoQueryString = `INSERT INTO musicians
            (display_name, bio, handle, spotify_id, access)
        VALUES
            ('temp display name -- edit me!', 'temp bio -- edit me!', 'temp-handle-${spotifyId}-${randomString}', '${spotifyId}', '${access}')
        ON CONFLICT (spotify_id) DO UPDATE SET
            access = '${access}';`

        db.query(upsertMusicianInfoQueryString).then(data => {
            console.log('just executed upsertMusicianInfoQueryString, and the returned data is:', data);
            return next();
        })

    } catch(err) {
        return next({
            log: 'error adding/syncing spotify id and access token in db',
            status: err.statusCode,
            message: {error: 'failed to sync spotify id and access token with db'}
        });
    }
}


// delete the cookies containing a musician's access and refresh tokens
authController.deleteCookies = (req, res, next) => {
    res.clearCookie('access').clearCookie('refresh').clearCookie('spotifyId');
    return next();
}


module.exports = authController;